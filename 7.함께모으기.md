# 함께 모으기
마틴 파울러는 객체지향 설계 안에 존재하는 세 가지 상호 연관된 관점에 관해 설명한다.

1) 개념 관점 : 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현한다. 도메인이란 사용자들이 관심을 가지고 있는 특정 분야나 주제를 말하며 소프트웨어는 도메인에 존재하는 문제를 해결하기 위해 개발된다.
2) 명세 관점 : 도메인 개념이 아닌 소프트웨어 안에서 살아 숨쉬는 객체들의 책임에 초점을 맞추게 된다. 즉 객체의 인터페이스를 바라보게 된다. 명세 관점에서 프로그래머는 객체가 협력을 위해 무엇을 할 수 있는가에 초점을 맞춘다. __인터페이스와 구현을 분리하는 것은 훌륭한 객체지향 설계를 낳는 가장 기본적인 원칙이다.__
3) 구현 관점 : 실제 작업을 수행하는 코드와 연관돼 있다. 객체들이 책임을 수행하는 데 필요한 동작하는 코드를 작성하는데 초점을 맞춘다. 따라서 객체의 책임을 어떻게 수행할 것인가에 맞추어 인터페이스를 구현하는 데 필요한 속성과 메서드를 클래스에 추가한다.

위 설명은 세 가지 관점의 순서대로 소프트웨어를 개발하는 것이 아니라 동일한 클래스에 대해 세 가지 다른 방향에서 바라보는 것을 의미한다. 클래스가 은유하는 개념은 도메인 관점, 클래스의 공용 인터페이스는 명세 관점을 반영하고, 클래스의 속성과 메서드는 구현 관점을 반영한다. 클래스는 세 가지 관점을 모두 수용할 수 있도록 개념, 인터페이스, 구현을 함께 드러내야 한다. 

### __커피 전문점 도메인__
커피 전문점에는 메뉴판이 존재한다. 메뉴판에는 아메리카노, 카푸치노, 카라메 마끼아또, 에스프레소 등 커피메뉴가 있다. 객체지향 관점에서 메뉴판은 하나의 객체이다. 메뉴 항목들 역시 객체이고, 메뉴판은 메뉴 항목 객체들을 포함하는 객체이다. 커피를 주문하는 손님, 주문을 받아 커피를 제조하는 바리스타 역시 객체들이다.

이 객체들의 관계를 보면 하나의 메뉴판 객체는 다수의 메뉴 항목 객체로 구성되어 있고, 하나의 단위로 움직인다. 따라서 두 객체의 관계는 포함 관계다. 손님은 메뉴판을 알아야 커피를 선택할 수 있다. 하지만 메뉴판은 손님의 일부가 아니므로 이 둘 사이의 관계는 포함은 아니지만 서로 알고 있어야 하는 경우 이므로 연관 관계다. 바리스타와 커피, 바리스타와 손님도 바리스타의 일부가 아니고 서로 알고있어야할 뿐이므로 이들 역시 연관관계이다.

협력을 설계할 때는 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야한다. 이는 메시지를 먼저 선택하고 그 후에 메시지를 수신하기에 적절한 객체를 선택해야한다는 것을 의미한다. 

[구현]

    class Customer {
        public void order(String menuName, Menu menu, Barista barista) {
            MenuItem menuItem = menu.choose(menuName);
            Coffee cofee = barista.makeCoffee(menuItem);
            ...
        }
    }

    class Menu {
        private List<MenuItem> items;

        public Menu(List<MenuItem> items) {
            this.items = items;
        }

        public MenuItem choose(String name) {
            for(MenuItem each : items) {
                if(each.getName().equals(name)) {
                    return each;
                }
            }
            return null;
        }
    }

    class Barista {
        public Coffee makeCoffee(MenuItem menuItem) {
            Coffee coffee = new Coffee(menuItem);
            return coffee;
        }
    }

    class Coffee {
        private String name;
        private int price;

        public Coffee(MenuItem menuItem) {
            this.name = menuItem.getName();
            this.price = menuItem.cost();
        }
    }

    public class MenuItem{
        private String name;
        private int price;

        public MenuItem(String name, int price) {
            this.name = name;
            this.price = price;
        }

        public int cost() {
            return price;
        }

        public String getName() {
            return name;
        }
    }

### __코드와 세 가지 관점__
위 구현에서 작성한 코드는 개념 관점, 명세 관점, 구현 관점에서 설명해준다. 개념 관점에서 바라보면 Customer, Menu, MenuItem, Barista, Coffee 클래스가 보인다. 클래스가 도메인 개념의 특성을 최대한 수용하면 변경을 관리하기 쉽고 유지보수성을 향상시킬 수 있다. 

명세 관점은 클래스의 인터페이스를 바라본다. 클래스의 public 메서드는 다른 클래스가 협력할 수 있는 공용 인터페이스를 드러낸다. 공용 인터페이스는 외부의 객체가 해당 객체에 접근할 수 있는 유일한 부분이다. 인터페이스를 수정하면 해당 객체와 협력하는 모든 객체에게 영향을 미칠 수밖에 없다. 최대한 변화에 안정적인 인터페이스를 만들기 위해서는 인터페이스를 통해 구현과 관련된 세부 사항이 드러나지 않게 해야한다. 

구현 관점은 클래스의 내부 구현을 바라본다. 클래스의 메서드와 속성은 구현에 속하며 공용 이터페이스의 일부가 아니다. 따라서 메서드의 구현과 속성의 변경은 원칙적으로 외부의 객체에게 영향을 미쳐서는 안 된다. 이는 메서드와 속성이 철저하게 클래스 내부로 캡슐화돼야 한다는 것을 의미한다.

어떤 메시지가 있을 때 그 메시지를 수신할 객체를 어떻게 선택하는가? 도메인 개념 중에서 가장 적절한 것을 선택하는 것이다. 도메인에 대한 지식을 기반으로 코드의 구조와 의미를 쉽게 유추할 수 있다. 이것은 시스템의 유지보수성에 커다란 영향을 미친다. 소프트웨어 클래스가 도메인 개념을 따르면 변화에 쉽게 대응할 수 있다.

정리 ) 중요한 것은 인터페이스와 구현을 분리해야한다. 명세 관점과 구현 관점이 뒤섞이면 안 된다. 명세 관점은 클래스의 안정적인 측면을 드러내야하고, 구현 관점은 클래스의 불안정한 측면을 드러내야한다. 클래스를 봤을 때 클래스를 명세 관점과 구현 관점으로 나눠볼 수 있어야 한다. 캡슐화를 위반해서 구현을 인터페이스 밖으로 노출해서도 안 되고, 인터페이스와 구현을 명확하게 분리하지 않고 흐릿하게 섞어 놓아서도 안 된다.