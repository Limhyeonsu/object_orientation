# 추상화 기법
추상화 기법의 종류

### __분류와 인스턴스화__
객체를 분류하고 범주로 묶는 것은 객체들의 특정 집합에 공통의 개념을 적용하는 것을 의미한다. 개념이란 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어다. 또 세상에 존재하는 객체에 개념을 적용하는 과정을 분류라고 한다. 분류는 객체를 특정한 개념을 나타내는 집합의 구성 요소로 포함 시킨다.

사람들은 분류를 통해 개별 현상을 하나의 개념으로 다룬다. 이때 수많은 개별적인 현상들을 객체라고 하고, 하나의 개념을 타입이라고 한다. 즉 분류는 객체를 타입과 연관시키는 것이다. 

객체를 타입에 따라 분류하기 위해성는 객체가 타입에 속하는지 여부를 확인할 수 있어야 한다. 타입을 객체의 분류 장치로서 적용할 수 있으려면 다음과 같은 세 가지 관점에서의 정의가 필요하다.

* 심볼 : 타입을 가리키는 간략한 이름이나 명칭
* 내연 : 타입의 완전한 정의, 내연의 의미를 이용해 객체가 타입에 속하는지 여부를 확인할 수 있다.
* 외연 : 타입에 속하는 모든 객체들의 집합

예) 자동차(심볼), 원동기를 동력원으로 해서 주행하는 사람이나 화물을 운반하는 기계(내연), 여러 자동차들(외연)

한 객체가 한 시점에 하나의 타입에만 속하는 것을 단일 분류라고 하고, 한 시점에 여러 타입에 속할 경우 다중 분류라고 한다. 대부분의 객체지향 프로그래밍 언어들은 단일 분류만을 지원한다. 또 객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우 동적 분류라고 하고, 자신의 타입을 변경할 수 없는 경우 정적 분류라고 한다. 대부분의 언어는 클래스로 부터 인스턴스를 생성 후 클래스를 변경할 수 있는 방법을 제공하지 않는다. 즉 객체의 타입을 변경할 수 없다. 따라서 대부분의 언어는 정적 분류만을 허용한다.

다중 분류와 동적 분류는 개념적인 관점에서 도메인을 분석하는데 유용하다.

객체지향 프로그래밍 언어를 이용하여 타입을 구현하는 보편적인 방법은 클래스를 이용하는 것이다. 클래스외에도 인스턴스를 생성할 수 없는 추상 클래스나 인터페이스를 이용해 타입을 구현할 수도 있다. 클래스 기반의 객체지향 언어에서 클래스는 객체가 공유하는 본질적인 속성을 정의한다. 동일한 범주에 속하는 객체는 동일한 클래스의 인스턴스여야 한다.

### __일반화와 특수화__
계층구조에서는 좀 더 세부적인 범주가 계층의 하위에 위치하고 좀 더 일반적인 범주가 계층의 상위에 위치한다. 이 때 계층의 상위에 위치한 범주를 계층의 하위에 위치한 범주의 일반화라고 하고, 계층의 하위에 위치한 범주는 계층의 상위에 위치한 범주의 특수화라고 한다.

객체지향에서 어떤 타입이 다른 타입보다 일반적이라면 이 타입을 슈퍼타입이라고 하고, 어떤 타입이 다른 타입보다 좀 더 특수하다면 이 타입을 서브타입 이라고 한다. 일반화와 특수화 계층 구조에서 서브타입은 슈퍼타입이 가진 본질적인 속성과 함께 자신만의 추가적인 속성을 갖는다. 

예) 내연의 관점에서 고양이는 육식동물의 특수화이고, 육식동물은 포유류의 특수화이기 때문에 고양이는 육식동물과 포유류가 가진 모든 본질적인 속성을 포함한다. 외연의 관점에서 서브타입은 슈퍼타입의 부분집합으로 표현된다.

크레이그 라만은 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 다음의 규칙을 준수해야한다고 했다.
* 100% 규칙 : 슈퍼타입의 정의가 100% 서브타입에 적용돼야만 한다. 서브타입은 속성과 연관관계 면에서 슈퍼타입과 100% 일치해야한다.
* is-a 규칙 : 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야한다. ex) 고양이는 육식동물이다. ~이다 관계

프로그래밍에서 일반화와 특수화 관계를 구현하는 일반적인 방법은 클래스간의 상속을 사용하는 것이다. 하지만 모든 상속 관계가 일반화 관계인 것은 아니다.

일반화의 원칙은 한 타입이 다른 타입의 서브타입이 되기 위해서는 슈퍼타입에 순응해야한다는 것이다. 순응에는 구조적인 순응, 행위적인 순응이 있다.

구조적인 순응은 타입의 내연과 관련된 100% 규칙을 의미한다. 즉 서브타입이 슈퍼타입을 대체하더라도 구조에 관한 동일한 기대 집합을 만족시킬 수 있다.  행위적인 순응은 타입의 행위에 관한 것이며 서브타입은 슈퍼타입을 행위적으로 대체 가능해야한다. 흔히 리스코프 치환 원칙이라고도 한다. 

상속은 서브타이핑(서브클래스가 슈퍼클래스를 대체할 수 있는 경우), 서브클래싱(서브클래스가 슈퍼클래스를 대체할 수 없는 경우)의 두 가지 용도로 사용될 수 있다. 서브 타이핑은 설계의 유연성이 목표이고 인터페이스 상속이라고 한다. 서브 클래싱은 코드의 중복을 제거하고 재사용이 목적으로 구현 상속이라고 한다.